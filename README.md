# sentry-guarder
## 分布式限流降级
### 1. 限流

> 可以理解为是一个控制流量阈值或调节比例的功能，在前端网站面对大流量访问的时候，可以对流量进行控制，防止大流量对后端核心系统造成破坏，导致服务不可用的情况。即通过调节流量阈值来控制通过系统的最大流量值，保证系统安全可靠运行。
> 
> 分为接入层限流，应用层降级，我们这里实现的是应用层降级

### 1.1 常见算法
1. 令牌桶  以固定速率添加令牌，填满为止，当有n个请求时，删除n个令牌，当不够时，则请求会被限流   支持突发流量
2. 漏桶   固定容量的漏桶  按照规定速率流出， 流入速率不限，当漏桶满了，流入的请求会被限流，如果桶空了，则不需要流出
3. 计数器/滑动窗口 需要把时间分割的较细才能较好限流   [参考](http://www.kissyu.org/2016/08/13/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/)

### 2. 降级
> 服务降级，把非核心依赖降级，防止拖垮核心服务, 如一些页面中的推荐信息，可以在大促之前做降级

#### 2.1 常见分类
1. 页面降级 （对应一个http请求)
2. 页面片段降级 (页面部分片段缓存)
3. 功能降级（搜索，推荐，统计)
4. 服务接口降级 (服务化接口降级， 针对的是消费端降级) [参考](https://help.aliyun.com/document_detail/44389.html?spm=5176.doc44387.6.601.E8gmq7)

### 3. 架构设计

限流分而自治—配置推送—同步校验—异步计数（Redis + Semaphore + RateLimiter）

Redis统一管理限流配置，并推送至每个JVM实例中，限流计数器（并发量、请求速率）由JVM本地进行内存级的计数，监控数据异步周期性上报Redis。

优势：解决了JVM扩缩容时限流配置参数的频繁变更问题
劣势：没有实现集中式资源限流

![架构图](http://chuantu.biz/t6/168/1512610942x-1566638217.png)

### 4. 使用

限流

	@Limiting 
	public List<GroupDO> shortQueryWithSleepLong()
	{
	}
	
降级

	public static void main(String[] args) throws Throwable
	{
		// 降级标识 正常调用  降级调用
		boolean sendSmsResult = DemotionUtils.call(“降级标识”, () -> sendSms(phone, content), () -> true);
	}
    
### 5. 控制台

	实现全局控制，统计
	
### 6. 性能优化
	计数器使用 LongAdder 替换 AtomicLong
	 
